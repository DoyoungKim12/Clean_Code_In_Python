
# CH2. 파이썬스러운(Pythonic) 코드
- 아이디어를 파이썬으로 표현하는 방식과 그 특수성을 살펴볼 것
- 프로그래밍에서 관용구(idiom)는 특정 작업을 수행하기 위해 코드를 작성하는 특별한 방법
  - 일반적으로 관용적 표현이란 2개 이상의 단어가 모여 원래와 다른 의미를 가지는 것
    - 예를 들어, 호랑이 담배피던 시절이라고 하면 우리는 누구나 아주 먼 옛날을 뜻한다고 이해한다.  
  - 관용구는 코드이므로 언어에 따라 다르며, 이 관용구를 따른 코드를 '관용적'이라고 하는데 특히 파이썬에서는 이를 **'파이썬스럽다'** 고 한다.
  - 권장사항을 따르고 파이썬스러운 코드를 작성하는 이유는 여러가지가 있다.
    - 관용적인 방식으로 작성한 코드가 일반적으로 더 나은 성능을 낸다.
    - 코드의 사이즈가 더 작고 이해하기도 쉽다.
    - 전체 개발팀이 동일한 패턴과 구조에 익숙해지면 실수를 줄이고 문제의 본질에 집중할 수 있다.
- 이 장의 목표는 아래와 같다.
  - 인덱스와 슬라이스를 이해하고, 인덱싱 가능한 객체를 올바른 방식으로 구현하기
  - 시퀀스와 이터러블 구현하기
  - 컨텍스트 관리자를 만드는 모범사례 연구
  - 매직 메서드를 사용해 보다 관용적인 코드 구현
  - 파이썬에서 부작용을 유발하는 흔한 실수 피하기  

<br><br>

## 인덱스와 슬라이스
- 일부 데이터구조, 또는 타입은 자신이 가진 요소에 인덱스로 접근하는 것을 지원함
  - 파이썬은 다른 언어와 색다른 방법으로 접근하는 것을 지원한다.
    - 음수 인덱스를 사용한 접근
    - slice를 사용한 특정 구간의 요소로의 접근
    - 튜플, 문자열, 리스트의 특정 요소를 가져오려고 한다면, for 루프를 돌면서 수작업으로 요소를 선택하지 말고 이러한 방법을 사용하는 것이 좋다.

<br>

### 자체 시퀀스 생성
- 위에서 설명한 기능은 \_\_getitem__이라는 매직메서드 덕분에 동작 
  - myobject\[key]와 같는 형태를 사용할 때 호출되는 메서드
  - key에 해당하는 대괄호 안의 값을 파라미터로 전달

<br>

- 시퀀스는 \_\_getitem__과 \_\_len__을 모두 구현하는 객체이므로 반복이 가능 
  - 리스트, 튜플, 문자열은 표준 라이브러리에 있는 시퀀스 객체의 대표적인 예시

<br>

- 여기서는 시퀀스나 이터러블 객체를 만들지 않고 키로 객체의 특정 요소를 가져오는 방법에 대해 다룰 것

<br>

- 업무 도메인에서 사용하는 사용자정의 클래스에 \_\_getitem__을 구현할 때 고려해야 할 사항
  - 클래스가 표준 라이브러리의 래퍼(wrapper)일 경우, 기본 객체에 가능한 많은 동작을 위임할 수 있음
    - 즉, 클래스가 리스트의 래퍼인 경우, 리스트의 동일 메서드를 호출하여 호환성 유지 가능
    - 필요한 메서드가 있는 경우, 그냥 list 객체에 있는 동일한 메서드에 위임하면 됨
  - 래퍼도 아니고 내장 객체도 사용하지 않는 경우는 자신만의 시퀀스를 구현할 수 있으나 아래 사항에 유의
    - 범위로 인덱싱한 결과는 해당 클래스와 같은 타입의 인스턴스여야 함
    - slice에 의해 제공된 범위는 마지막 요소를 제외해야 함

<br><br>   

## 컨텍스트 관리자 (context manager)
- 컨텍스트 관리자는 파이썬이 제공하는 유용한 기능으로, 특별히 유용한 이유는 패턴에 잘 대응되기 때문
  - 해당 패턴은 모든 코드에 적용될 수 있으며, 사전조건과 사후조건을 가짐 (즉, 주요동작 전후에 작업을 실행하려 할 때 유용함)
  - 일반적으로 리소스 관리와 관련하여 컨텍스트 관리자를 자주 볼 수 있음
    - 예를 들어, 파일을 열면 파일 디스크립터 누수를 막기 위해 작업이 끝나면 적절히 닫히길 기대함
    - 서비스나 소켓에 대한 연결을 열었을 때에도 적절히 닫거나 임시파일을 제거하는 등의 작업이 필요함
  - 이러한 모든 경우에는 일반적으로 할당된 모든 리소스를 제거해야 함
    - 모든 것이 잘 처리되었을 경우의 해제는 쉽지만, 예외가 발생하거나 오류를 처리해야 한다면?
    - 가장 일반적인 방법은 finally 블록에 정리 코드를 넣는 것
    - 그러나 같은 기능을 **매우 우아하고 파이썬스러운** 방법으로 구현할 수 있음

```python
# 파이썬스럽지 못한 코드
fd = open(filename)
try:
  process_file(fd)
finally:
  fd.close()
  
# 파이썬스러운 코드
# with문은 컨텍스트 관리자로 진입하게 함
# open 함수는 컨텍스트 관리자 프로토콜을 구현 (즉, 예외가 발생한 경우에도 블록이 완료되면 파일이 자동으로 닫힘)
with open(filename) as fd:
  process_file(fd)
```

<br>

- 컨텍스트 관리자는 \_\_enter__와 \_\_exit__의 2개 매직메서드로 구성됨
  - 첫번째 줄에서의 with문은  \_\_enter__메서드를 호출, 이 메서드가 무엇를 반환하든 as 이후에 지정된 변수에 할당
  - 해당 라인이 시작되면 다른 파이썬 코드가 실행될 수 있는 새로운 컨텍스트로 진입
  - 해당 블록의 마지막 문장이 끝나면 컨텍스트가 종료, 처음 호출한 컨텍스트 관리자 객체의 \_\_exit__메서드 호출
    - 예외, 오류가 있는 경우에도 여전히 \_\_exit__ 메서드가 호출되므로 정리 조건을 안전하게 실행하기 편함

<br>

- 컨텍스트 관리자가 리소스 관리에 자주 사용되긴 하지만, 오직 해당 분야에만 사용하는 것은 아님
  - 블록 전후에 필요한 특정 로직을 제공하기 위해 자체 컨텍스트 관리자를 구현할 수도 있음
  - 관심사를 분리하고 독립적으로 유지되어야 하는 코드를 분리하기 좋은 방법

<br>

- 스크립트를 사용해 데이터베이스 백업을 하려는 경우를 생각해보자.
  - 주의사항은 백업을 오프라인 상태에서 해야한다는 점
  - 백업이 끝나면 백업 프로세스의 성공 여부에 관계없이 프로세스를 다시 시작해야 함
  - 첫번째 방법은 서비스 중지 > 백업 > 예외 및 특이사항 처리 > 서비스 재시작 으로 이루어진 거대한 단일 함수를 만드는 것
    - 진짜 이렇게 구현하는 경우가 있기 때문에, 바로 해결법을 제시하지 않고 좀 더 자세히 살펴봄

```python
def stop_database():
  run("systemctl stop postgresql.service")

def start_database():
  run("systemctl start postgresql.service")
  
class DBhandler:
  def __enter__(self):
    stop_database()
    return self
    
  def __exit__(self, exc_type, ex_value, ex_traceback):
    start_database()
    
def db_backup():
  run("pg_dump database")
  
# main 함수에서는 유지보수 작업과 상관없이 백업 실행, 백업에 오류가 있어도 여전히 __exit__ 호출
def main():
# 블록 내부에서 컨텍스트 관리자의 결과를 사용하지 않음
# 적어도 이런 경우에는 __enter__의 반환 값은 쓸모가 없음 (as로 반환되는 무언가를 블록 내부에서 써야 한다는 말인가?)
# 일반적으로 필수는 아니지만, __enter__에서 무언가를 반환하는 것이 좋은 습관 (디자인할 때 블록이 시작된 후에 무엇이 필요한지 고려해야 함)
  with DBHandler(): 
    db_backup()
```

<br>

###  컨텍스트 관리자 구현
- 앞의 예제와 같은 방법으로 컨텍스트 관리자를 구현할 수 있음
  - \_\_enter__와 \_\_exit__ 매직메서드만 구현하면 해당 객체는 컨텍스트 관리자 프로토콜을 지원
  - 이렇게 구현하는 것이 일반적이지만 유일한 방법은 아님
  - 이 섹션에서는 컨텍스트 관리자를 좀 더 간결하게 구현하는 방법과, 특히 contextlib 모듈을 사용하여 보다 쉽게 구현하는 방법을 살펴볼 것

<br>

- contextlib 모듈은 컨텍스트 관리자를 구현하거나 더 간결한 코드를 작성하는 데 도움이 되는 많은 도우미 함수와 객체를 제공
  - 먼저 contextmanager 데코레이터를 보자
  - 함수에 contextlib.contextmanager 데코레이터를 적용하면 해당 함수의 코드를     












