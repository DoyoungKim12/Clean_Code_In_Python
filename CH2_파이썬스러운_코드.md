
# CH2. 파이썬스러운(Pythonic) 코드
- 아이디어를 파이썬으로 표현하는 방식과 그 특수성을 살펴볼 것
- 프로그래밍에서 관용구(idiom)는 특정 작업을 수행하기 위해 코드를 작성하는 특별한 방법
  - 일반적으로 관용적 표현이란 2개 이상의 단어가 모여 원래와 다른 의미를 가지는 것
    - 예를 들어, 호랑이 담배피던 시절이라고 하면 우리는 누구나 아주 먼 옛날을 뜻한다고 이해한다.  
  - 관용구는 코드이므로 언어에 따라 다르며, 이 관용구를 따른 코드를 '관용적'이라고 하는데 특히 파이썬에서는 이를 **'파이썬스럽다'** 고 한다.
  - 권장사항을 따르고 파이썬스러운 코드를 작성하는 이유는 여러가지가 있다.
    - 관용적인 방식으로 작성한 코드가 일반적으로 더 나은 성능을 낸다.
    - 코드의 사이즈가 더 작고 이해하기도 쉽다.
    - 전체 개발팀이 동일한 패턴과 구조에 익숙해지면 실수를 줄이고 문제의 본질에 집중할 수 있다.
- 이 장의 목표는 아래와 같다.
  - 인덱스와 슬라이스를 이해하고, 인덱싱 가능한 객체를 올바른 방식으로 구현하기
  - 시퀀스와 이터러블 구현하기
  - 컨텍스트 관리자를 만드는 모범사례 연구
  - 매직 메서드를 사용해 보다 관용적인 코드 구현
  - 파이썬에서 부작용을 유발하는 흔한 실수 피하기  

<br><br>

## 인덱스와 슬라이스
- 일부 데이터구조, 또는 타입은 자신이 가진 요소에 인덱스로 접근하는 것을 지원함
  - 파이썬은 다른 언어와 색다른 방법으로 접근하는 것을 지원한다.
    - 음수 인덱스를 사용한 접근
    - slice를 사용한 특정 구간의 요소로의 접근
    - 튜플, 문자열, 리스트의 특정 요소를 가져오려고 한다면, for 루프를 돌면서 수작업으로 요소를 선택하지 말고 이러한 방법을 사용하는 것이 좋다.

<br>

### 자체 시퀀스 생성
- 위에서 설명한 기능은 \_\_getitem__이라는 매직메서드 덕분에 동작 
  - myobject\[key]와 같는 형태를 사용할 때 호출되는 메서드
  - key에 해당하는 대괄호 안의 값을 파라미터로 전달

<br>

- 시퀀스는 \_\_getitem__과 \_\_len__을 모두 구현하는 객체이므로 반복이 가능 
  - 리스트, 튜플, 문자열은 표준 라이브러리에 있는 시퀀스 객체의 대표적인 예시

<br>

- 여기서는 시퀀스나 이터러블 객체를 만들지 않고 키로 객체의 특정 요소를 가져오는 방법에 대해 다룰 것

<br>

- 업무 도메인에서 사용하는 사용자정의 클래스에 \_\_getitem__을 구현할 때 고려해야 할 사항
  - 클래스가 표준 라이브러리의 래퍼(wrapper)일 경우, 기본 객체에 가능한 많은 동작을 위임할 수 있음
    - 즉, 클래스가 리스트의 래퍼인 경우, 리스트의 동일 메서드를 호출하여 호환성 유지 가능
    - 필요한 메서드가 있는 경우, 그냥 list 객체에 있는 동일한 메서드에 위임하면 됨
  - 래퍼도 아니고 내장 객체도 사용하지 않는 경우는 자신만의 시퀀스를 구현할 수 있으나 아래 사항에 유의
    - 범위로 인덱싱한 결과는 해당 클래스와 같은 타입의 인스턴스여야 함
    - slice에 의해 제공된 범위는 마지막 요소를 제외해야 함

<br><br>   

## 컨텍스트 관리자 (context manager)
- 컨텍스트 관리자는 파이썬이 제공하는 유용한 기능으로, 특별히 유용한 이유는 패턴에 잘 대응되기 때문
  - 해당 패턴은 모든 코드에 적용될 수 있으며, 사전조건과 사후조건을 가짐 (즉, 주요동작 전후에 작업을 실행하려 할 때 유용함)
  - 일반적으로 리소스 관리와 관련하여 컨텍스트 관리자를 자주 볼 수 있음
    - 예를 들어, 파일을 열면 파일 디스크립터 누수를 막기 위해 작업이 끝나면 적절히 닫히길 기대함
    - 서비스나 소켓에 대한 연결을 열었을 때에도 적절히 닫거나 임시파일을 제거하는 등의 작업이 필요함
  - 이러한 모든 경우에는 일반적으로 할당된 모든 리소스를 제거해야 함
    - 모든 것이 잘 처리되었을 경우의 해제는 쉽지만, 예외가 발생하거나 오류를 처리해야 한다면?
    - 가장 일반적인 방법은 finally 블록에 정리 코드를 넣는 것
    - 그러나 같은 기능을 **매우 우아하고 파이썬스러운** 방법으로 구현할 수 있음

<br>

```python
# 파이썬스럽지 못한 코드
fd = open(filename)
try:
  process_file(fd)
finally:
  fd.close()
  
# 파이썬스러운 코드
# with문은 컨텍스트 관리자로 진입하게 함
# open 함수는 컨텍스트 관리자 프로토콜을 구현 (즉, 예외가 발생한 경우에도 블록이 완료되면 파일이 자동으로 닫힘)
with open(filename) as fd:
  process_file(fd)
```

<br>

- 컨텍스트 관리자는 \_\_enter__와 \_\_exit__의 2개 매직메서드로 구성됨
  - 첫번째 줄에서의 with문은  \_\_enter__메서드를 호출, 이 메서드가 무엇를 반환하든 as 이후에 지정된 변수에 할당
  - 해당 라인이 시작되면 다른 파이썬 코드가 실행될 수 있는 새로운 컨텍스트로 진입
  - 해당 블록의 마지막 문장이 끝나면 컨텍스트가 종료, 처음 호출한 컨텍스트 관리자 객체의 \_\_exit__메서드 호출
    - 예외, 오류가 있는 경우에도 여전히 \_\_exit__ 메서드가 호출되므로 정리 조건을 안전하게 실행하기 편함

<br>

- 컨텍스트 관리자가 리소스 관리에 자주 사용되긴 하지만, 오직 해당 분야에만 사용하는 것은 아님
  - 블록 전후에 필요한 특정 로직을 제공하기 위해 자체 컨텍스트 관리자를 구현할 수도 있음
  - 관심사를 분리하고 독립적으로 유지되어야 하는 코드를 분리하기 좋은 방법

<br>

- 스크립트를 사용해 데이터베이스 백업을 하려는 경우를 생각해보자.
  - 주의사항은 백업을 오프라인 상태에서 해야한다는 점
  - 백업이 끝나면 백업 프로세스의 성공 여부에 관계없이 프로세스를 다시 시작해야 함
  - 첫번째 방법은 서비스 중지 > 백업 > 예외 및 특이사항 처리 > 서비스 재시작 으로 이루어진 거대한 단일 함수를 만드는 것
    - 진짜 이렇게 구현하는 경우가 있기 때문에, 바로 해결법을 제시하지 않고 좀 더 자세히 살펴봄

<br>

```python
def stop_database():
  run("systemctl stop postgresql.service")

def start_database():
  run("systemctl start postgresql.service")
  
class DBhandler:
  def __enter__(self):
    stop_database()
    return self
    
  def __exit__(self, exc_type, ex_value, ex_traceback):
    start_database()
    
def db_backup():
  run("pg_dump database")
  
# main 함수에서는 유지보수 작업과 상관없이 백업 실행, 백업에 오류가 있어도 여전히 __exit__ 호출
# __exit__에서는 블록에서 발생한 예외를 파라미터로 받음 (블록에 예외가 없으면 모두 None인 값들)
# __exit__의 반환 값을 잘 생각해야 함. 만약 True를 반환하면 잠재적으로 발생한 예외를 호출자에게 전파하지 않고 멈춤을 의미함
# 위 예시에서는 따로 return을 쓰지 않았는데, 그럼 True를 반환한다는 뜻?

def main():
# 블록 내부에서 컨텍스트 관리자의 결과를 사용하지 않음
# 적어도 이런 경우에는 __enter__의 반환 값은 쓸모가 없음 (as로 반환되는 무언가를 블록 내부에서 써야 한다는 말인가?)
# 일반적으로 필수는 아니지만, __enter__에서 무언가를 반환하는 것이 좋은 습관 (디자인할 때 블록이 시작된 후에 무엇이 필요한지 고려해야 함)
  with DBHandler(): 
    db_backup()
```

<br>

###  컨텍스트 관리자 구현
- 앞의 예제와 같은 방법으로 컨텍스트 관리자를 구현할 수 있음
  - \_\_enter__와 \_\_exit__ 매직메서드만 구현하면 해당 객체는 컨텍스트 관리자 프로토콜을 지원
  - 이렇게 구현하는 것이 일반적이지만 유일한 방법은 아님
  - 이 섹션에서는 컨텍스트 관리자를 좀 더 간결하게 구현하는 방법과, 특히 contextlib 모듈을 사용하여 보다 쉽게 구현하는 방법을 살펴볼 것

<br>

- contextlib 모듈은 컨텍스트 관리자를 구현하거나 더 간결한 코드를 작성하는 데 도움이 되는 많은 도우미 함수와 객체를 제공
  - 먼저 contextmanager 데코레이터를 보자
    - 함수에 contextlib.contextmanager 데코레이터를 적용하면 해당 함수의 코드를 컨텍스트 관리자로 변환함
    - 함수는 **제러레이터**라는 특수한 함수의 형태여야 함 (코드의 문장을 \_\_enter__와 \_\_exit__ 매직메서드로 분리)
    - 지금은 데코레이터와 제너레이터에 익숙하지 않아도 아래 예제는 이해가능함 (관련하여 자세한 내용은 7장에서 다룸)

<br>

```python
import contextlib

@contextlib.contextmanager
def db_handler():
  stop_database()
  yeild
  start_database()
  
with db_handler():
  db_backup()
```

<br>

- 먼저 제너레이터 함수를 정의하고 @contextlib.contextmanager 데코레이터를 적용
  - yeild문을 사용했으므로 제너레이터 함수가 됨
  - 중요한 것은, 데코레이터를 사용하면 yeild문 앞의 모든 것은 \_\_enter__ 메서드의 일부로 취급된다는 것
  - yeild문 다음에 오는 모든 것들은 \_\_exit__ 로직이 됨

<br>

- 이렇게 컨텍스트 매니저를 작성하면 기존 함수를 리팩토링하기 쉬운 장점이 있음
  - 많은 상태를 관리할 필요가 없고, 다른 클래스와 독립된 컨텍스트 관리자 함수를 만드는 경우에는 이렇게 하는 것이 좋음
  - 컨텍스트 관리자를 구현할 수 있는 더 많은 방법이 있으며, 표준 라이브러리인 contextlib 패키지에 있음

<br>

- 또 다른 도우미 클래스는 contextlib.ContextDecorator이다.
  - 컨텍스트 관리자 안에서 실행될 함수에 데코레이터를 적용하기 위한 로직을 제공하는 믹스인 클래스
    - 믹스인 클래스는 다른 클래스에서 필요한 기능만 섞어서 사용할 수 있도록 메서드만을 제공하는 유틸리티 형태의 클래스를 말함
  - 컨텍스트 관리자 자체의 로직은 앞서 언급한 매직메서드를 구현하여 제공해야 함

<br>

```python 
class dbhandler_decorator(contextlib.ContextDecorator):
  def __enter__(self):
    stop_database()
  
  def __exit__(self, ext_type, ex_value, ex_traceback):
    start_database()

@dbhandler_decorator()
def offline_backup():
  run("pg_dump database")
```

<br>

- 이전 예제와 다른 점은 with문이 없다는 것
  - 그저 함수를 호출하기만 하면 offline_backup 함수가 컨텍스트 관리자 안에서 자동으로 실행됨
  - 원본 함수를 래핑하는 데코레이터가 하는 일
  - 이 접근법의 유일한 단점은 완전히 독립적이라는 것
    - 이것은 좋은 특성이지만, 컨텍스트 관리자 내부에서 사용하고자 하는 객체를 얻을 수는 없음을 의미
    - \_\_enter__ 메서드가 반환한 객체를 사용해야 하는 경우는 이전의 방식을 선택해야 함
  - 데코레이터로서의 장점은 로직을 한번만 정의하면 동일한 로직이 필요한 함수에 원하는 만큼 재사용할 수 있다는 것    

<br>

- 마지막으로 contextlib의 기능 하나를 살펴보자.
  - contextlib.suppress는 컨텍스트 관리자에서 사용하는 util 패키지로 제공한 예외가 발생한 경우에는 실패하지 않도록 함
  - try/except 블록에서 코드를 실행하고 예외를 전달하는 것과 비슷하지만, 차이점은 로직에서 자체적으로 처리하고 있는 예외임을 명시한다는 것

<br>

```python
import contextlib

# DataConversionException은 입력데이터가 이미 기대한 것과 같은 포맷이어서 변환할 필요가 없으므로, 무시해도 안전하다는 것을 뜻함
with contextlib.suppress(DataConversionException):
  parse_data(input_json_or_dict)
```

<br><br>

##  프로퍼티, 속성과 객체 메서드의 다른 타입들
- 파이썬 객체의 모든 프로퍼티와 함수는 public이다. 
  - 다른 언어들은 public, private, protected의 프로퍼티를 가짐
  - 즉, 호출자가 객체의 속성을 호출하지 못하도록 할 방법이 없음
  - 엄격한 강제사항은 없지만, 몇가지 규칙이 존재함
     - 밑줄(_)로 시작하는 속성은 해당 객체에 대해 private을 의미, **외부에서 호출하지 않기를 기대**하는 것
     - 다시 말하지만, 이걸 금지하는 것은 절대 아님
     - 파이썬에서의 밑줄이 어떤 특성을 갖는지 그 관습을 이해하고 속성의 범위를 살펴보는 것이 의미가 있을 것

<br>

### 파이썬에서의 밑줄
- 















